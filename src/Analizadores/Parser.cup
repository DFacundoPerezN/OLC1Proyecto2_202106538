/* 1. Package e importaciones */
package Analizadores; 
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import Estructuras.Simbolo;
import Estructuras.AST;

// 2. Codigo para el parser, variables, metodos 
parser code 
{:
    //Clases, objetos, variables, lista, etc... en sintaxis java    
    //Creo una lista de tipo String llamada 'salidas', donde guardare cada uno de las salidas analizadas
    //Para el proyecto se sugiere HashMap
    public List<String> salidas = new ArrayList<String>();
    public List<Simbolo> simbolos = new ArrayList<Simbolo>();

    public Map<String, Double> mapaDouble = new HashMap<>();    
    public Map<String, String> mapaString = new HashMap<>();

    public String graph;
:} 

// 3. Terminales 
terminal String PTCOMA,PARIZQ,PARDER,LLAVDER,LLAVIZQ,CORDER,CORIZQ,IGUAL,PUNTO,COMA, DOSPUNTOS, DOLLAR;
terminal String MAS,MENOS,POR,DIVIDIDO;
terminal String MENORQUE,MAYORQUE,EQUALS,MAYOROIGUAL,MENOROIGUAL,DISTINTO;
terminal String AND,OR,NOT;
terminal String ENTERO;
terminal String DECIMAL;
terminal String BOOLEANO;
terminal String ID;
terminal String STR,CHAR;
terminal String POTENCIA;
terminal String PR_VOID;
terminal String PR_MAIN,PR_DGLOBALES ;
terminal String PR_ENTERO;
terminal String PR_CADENA, PR_CHAR;
terminal String PR_DOBLE; 
terminal String PR_BIN; 
terminal String PR_CONSOLE;
terminal String PR_IMPRI;
terminal String PR_EJECUTAR;
terminal String PR_SI, PR_SINO, PR_PARA, PR_SELECT, PR_CASO, PR_PDEFECT, PR_CORTAR, PR_CONTINUAR,PR_MIENTRAS, PR_HACER;

// 4. No Terminales
non terminal ini, entradas;
non terminal sentencias, sentencia;
non terminal metodo, ejecutar;
non terminal valor_string, valor_double;
non terminal elementos_double;
non terminal sentencia_print;
non terminal actualizacion, incremento, decremento;
non terminal sentencia_declaracion,sentencia_llamar_metodo;
non terminal sentenciaIf, sentenciaElse, sentenciaSwitch, sentenciasCase,sentenciasExtra,usoBreak;
non terminal sentenciaFor, sentenciaDoWhile, sentenciaWhile;
non terminal lista_constructor;
non terminal expresion;
non terminal tipo_dato;
non terminal lista;
non terminal elementos;
non terminal miembro;

// 5. Precedencias
precedence nonassoc POTENCIA;
precedence left MAS,MENOS,COMA;
precedence left POR,DIVIDIDO;
precedence left  MENORQUE,MAYORQUE,EQUALS,MAYOROIGUAL,MENOROIGUAL,DISTINTO;
precedence left AND,OR;
precedence right NOT; 


// 6. Producciones
start with ini; 
ini::= entradas
;

entradas ::= sentencias:a 
            {: AST e = new AST("entrada") ; 
                e.hijos = ((List<AST>) a) ;  
                System.out.println(e.hijos.size());
                e.imprimirInfo(); graph= e.infoGraphviz(0); System.out.println(graph); //funcion para graficar arbol:}
            
;

sentencias ::= sentencias:a sentencia:b {: List<AST> sentencias = (List<AST>)a ; 
                                            sentencias.add((AST)b); 
                                        RESULT=sentencias; :}
              | sentencia:a  {:List<AST> inicial = new ArrayList<AST>(); 
                        inicial.add((AST)a);
                        RESULT = inicial;
                    :}
              |sentencias:a error:b     {:RESULT= null;:}
; 

metodo ::= PR_VOID ID:a PARIZQ lista_constructor:b PARDER LLAVIZQ sentencias:c LLAVDER 
        {: simbolos.add(new Simbolo(a, "Metodo", "void","-", aleft, aright));
            AST metodo = new AST (a); metodo.hijos.add( (AST)b); metodo.hijos.addAll((List<AST>) c) ;  
        RESULT=metodo; :}

             |PR_VOID ID:a PARIZQ PARDER LLAVIZQ sentencias:c LLAVDER 
        {: simbolos.add(new Simbolo(a, "Metodo", "void", "-", aleft, aright));
        AST metodo = new AST (a); metodo.hijos.addAll((List<AST>) c) ;  
        RESULT=metodo;   :}
;

lista_constructor ::= lista_constructor:a COMA tipo_dato:b ID:c 
                {: List<AST> lista = (List<AST>)a; lista.add(new AST(b+" "+c)); 
                    AST variables = new AST("variabels entrada"); variables.hijos = lista; RESULT=variables; :}
                    |tipo_dato:a ID:b {: RESULT=List.of(a+" "+b); :}
;

ejecutar ::= PR_EJECUTAR sentencia_llamar_metodo:a {:RESULT= "ejecutar " +a;:}
; 

sentencia_llamar_metodo ::= ID:a PARIZQ PARDER PTCOMA {:RESULT= a + "();";:}
                | ID:a PARIZQ elementos:b PARDER PTCOMA {:RESULT= a + "("+b+") \n";:}
; 

elementos_double ::= valor_double:a {: RESULT = a;  :}
        | elementos_double:a COMA elementos_double :b {:RESULT=a+","+b;:}
;

valor_double ::= DECIMAL:a {:RESULT=a;:}
                | ID:a {:RESULT=mapaDouble.get(a);:}
;


sentencia ::= sentencia_print:a     {:RESULT=a;:}
            |sentencia_declaracion:a     {:RESULT= a ;:}
            |actualizacion:a {:RESULT=a;:}

            | sentenciaIf:a   {:RESULT= new AST("si");:}
            | sentenciaFor:a  {:RESULT=a;:}
            | sentenciaSwitch:a  {:RESULT=a;:}
            | sentenciaWhile:a   {:RESULT=a;:}
            | sentenciaDoWhile:a   {:RESULT=new AST((String)a);:}
            | sentencia_llamar_metodo:a   {:RESULT=new AST((String)a);:}

            | metodo:a     {:RESULT= a ;:}
            | ejecutar:a     {:RESULT=new AST((String)a);:}
            //| expresion:a     {:RESULT=new AST((String)a);:}
;

sentenciaIf ::= PR_SI PARIZQ expresion:a PARDER LLAVIZQ sentencias:b LLAVDER 
                    {: AST si = new AST("si"); AST exp = new AST("expresion"); exp.hijos.add((AST)a); si.hijos.add(exp) ;
                        AST sen = new AST("sentencias"); sen.hijos = (List<AST>)b; si.hijos.add(sen); 
                        RESULT=si; :}
                |PR_SI PARIZQ expresion:a PARDER LLAVIZQ sentencias:b LLAVDER sentenciaElse:c 
                    {: AST si = new AST("si"); AST exp = new AST("expresion"); exp.hijos.add((AST)a); si.hijos.add(exp) ;
                        AST sen = new AST("sentencias"); sen.hijos = (List<AST>)b; si.hijos.add(sen); 
                        RESULT=si; :}
;

sentenciaElse ::= PR_SINO PR_SI PARIZQ expresion:a PARDER LLAVIZQ sentencias LLAVDER  {: RESULT="\n elif "+ a +":{\n"  + "\n}"; :}
                |PR_SINO PR_SI PARIZQ expresion:a PARDER LLAVIZQ sentencias LLAVDER  sentenciaElse:c {: RESULT="\nelif "+ a +":{\n"  + "\n}"+c; :}
                |PR_SINO LLAVIZQ sentencias LLAVDER  {: RESULT="else :{\n" + "\n}"; :}
;

sentenciaFor ::= PR_PARA PARIZQ sentencia_declaracion:a  expresion:b PTCOMA actualizacion:c PARDER LLAVIZQ sentencias:d LLAVDER 
            {: AST para = new AST("para"); para.hijos.add((AST) a);  AST cond = new AST("condicion"); cond.hijos.add((AST) b);  //System.out.println("para declaracion bien" );
                para.hijos.add((AST) c);
                AST sentencias =  new AST("sentencias"); sentencias.hijos = ((List<AST>) d); para.hijos.add(sentencias); 
                RESULT=para; :}
;

sentenciaSwitch ::= PR_SELECT PARIZQ ID:a PARDER LLAVIZQ sentenciasCase:b LLAVDER  
    {: AST select = new AST("selector"); select.hijos.add(new AST(a));
    AST casos = new AST("casos"); casos.hijos = (List<AST>)b; select.hijos.add(casos);
    RESULT=select; :}
;

sentenciasCase ::= PR_CASO expresion:a DOSPUNTOS sentencias:b usoBreak  sentenciasCase:c 
                    {: AST caso = new AST("caso"); caso.hijos.add((AST)a);  AST exps = new AST("sentencias"); exps.hijos = ((List<AST>) b); caso.hijos.add(exps);
                        List<AST> casos = new ArrayList<>(); casos.add(caso); System.out.println(casos.size());
                        casos.addAll((List<AST>)c);  
                        casos.add(caso);  RESULT=casos ;:}
                | PR_CASO expresion:a DOSPUNTOS sentencias:b usoBreak 
                    {: AST caso = new AST("caso"); caso.hijos.add((AST)a);  AST exps = new AST("sentencias"); exps.hijos = ((List<AST>) b); caso.hijos.add(exps);
                        List<AST> salidas = List.of(caso); System.out.println("CASO con dato: "+salidas.get(0).dato); RESULT = salidas;:}
                | PR_PDEFECT DOSPUNTOS sentencias:b usoBreak 
                    {: AST pdefect = new AST("pordefecto"); AST exps = new AST("sentencias"); exps.hijos = ((List<AST>) b); pdefect.hijos.add(exps);
                        List<AST> salidas = List.of(pdefect); System.out.println("PORDECETE con dato: "+salidas.get(0).hijos.get(0).dato); RESULT = salidas;:}
;
usoBreak ::=  PR_CORTAR PTCOMA
;

sentenciasExtra ::= ID:a IGUAL expresion:b PTCOMA sentencias {: RESULT=a+"=" + b+ ";\n"; :}
;

sentenciaWhile ::= PR_MIENTRAS PARIZQ expresion:a PARDER LLAVIZQ sentencias:b LLAVDER 
        {: AST mientras = new AST("mientras"); AST condicion = new AST("condicion"); condicion.hijos.add((AST)a); mientras.hijos.add(condicion);
            AST sentencias = new AST("sentencias"); sentencias.hijos = (List<AST>)b; mientras.hijos.add(condicion);
        RESULT=mientras; :}
;

sentenciaDoWhile ::= PR_HACER LLAVIZQ sentencias LLAVDER PR_MIENTRAS PARIZQ expresion:a PARDER PTCOMA
    {: RESULT="while True:{" +"if ("+"):{ \n break \n}"+"\n}"; :}
;


sentencia_print ::= PR_IMPRI PARIZQ expresion:a PARDER PTCOMA
    {:
       System.out.println("Debo retornar esto POR CONSOLA: (" + ((AST)a).dato +");" ); AST impri = new AST("imprimir()"); impri.hijos.add((AST)a);
       //Inserto en la lista de salidas de la expresiÃ³n evaluada
       //salidas.add("print(" + a + ")");
       RESULT=impri;
    :}
;

sentencia_declaracion ::= tipo_dato:a ID:b IGUAL expresion:c PTCOMA 
                                {: simbolos.add(new Simbolo(b, "Variable", (String) a, "global" , aleft, aright)); 
                                    AST declara = new AST("declaracion"); declara.hijos.add(new AST((String)a)); 
                                    declara.hijos.add(new AST(b)); declara.hijos.add((AST)c);
                                    RESULT=declara ;:}
                        |ID:b IGUAL expresion:c PTCOMA {:RESULT=b+" = "+c+";\n";:}
                        |tipo_dato:a ID:b PTCOMA    {:RESULT=a+" "+b+";";:}
                        |tipo_dato:a CORIZQ CORDER ID:b IGUAL lista:c PTCOMA {:RESULT= a +" [] "+b+ " = " +c+ ";" ;:}
;

actualizacion ::= incremento:a {:RESULT=a;:}
                | decremento:a {:RESULT=a;:}
;

incremento ::= ID:a MAS MAS 
                {:AST incremento = new AST("incremento"); incremento.hijos.add(new AST((String)a)); 
                incremento.hijos.add(new AST("+")); incremento.hijos.add(new AST("+"));
                RESULT=incremento ;:}    
;
decremento ::= ID:a MENOS MENOS 
                {:AST decremento = new AST("declaracion"); decremento.hijos.add(new AST((String)a)); 
                decremento.hijos.add(new AST("-")); decremento.hijos.add(new AST("-"));
                RESULT=decremento ;:}    
;

lista ::= LLAVIZQ elementos:a LLAVDER {:RESULT="[" +a+ "]";:}
;

elementos ::= expresion:a   {:RESULT=a;:}
            | elementos:a COMA elementos:b {:RESULT= ""+a + "," + b+"";:}
;

tipo_dato ::= PR_ENTERO    {:RESULT="entero";:}
            |PR_DOBLE  {:RESULT="doble";:}
            |PR_CADENA {:RESULT="cadena";:}
            |PR_BIN    {:RESULT="binario";:}
            |PR_CHAR    {:RESULT="char";:}
;

expresion ::= expresion:a MAS expresion:b {: AST mas = new AST("+"); mas.hijos.add((AST)a); mas.hijos.add((AST)b); RESULT = mas; :}
            | expresion:a POR expresion:b {: AST por = new AST("*"); por.hijos.add((AST)a); por.hijos.add((AST)b); RESULT = por; :}
            | expresion:a MENOS expresion:b {: AST men = new AST("-"); men.hijos.add((AST)a); men.hijos.add((AST)b); RESULT = men; :}
            | expresion:a POTENCIA expresion:b {: AST pot = new AST("^"); pot.hijos.add((AST)a); pot.hijos.add((AST)b); RESULT = pot; :}
            | expresion:a DIVIDIDO expresion:b {: AST div = new AST("/"); div.hijos.add((AST)a); div.hijos.add((AST)b); RESULT = div; :}

            | expresion:a MAYORQUE expresion:b {: AST may = new AST(">"); may.hijos.add((AST)a); may.hijos.add((AST)b); RESULT = may; :}
            | expresion:a MENORQUE expresion:b {: AST men = new AST("<"); men.hijos.add((AST)a); men.hijos.add((AST)b); RESULT = men; :}
            | expresion:a MAYOROIGUAL expresion:b {: AST mayi = new AST(">="); mayi.hijos.add((AST)a); mayi.hijos.add((AST)b); RESULT = mayi; :}
            | expresion:a MENOROIGUAL expresion:b {: AST meni = new AST("<="); meni.hijos.add((AST)a); meni.hijos.add((AST)b); RESULT = meni; :}
            | expresion:a EQUALS expresion:b {: AST eq = new AST("=="); eq.hijos.add((AST)a); eq.hijos.add((AST)b); RESULT = eq; :}
            | expresion:a DISTINTO expresion:b {: AST dis = new AST("!="); dis.hijos.add((AST)a); dis.hijos.add((AST)b); RESULT = dis; :}

            | expresion:a AND expresion:b {: AST and = new AST("&&"); and.hijos.add((AST)a); and.hijos.add((AST)b); RESULT = and; :}
            | expresion:a OR expresion:b {: AST or = new AST("||"); or.hijos.add((AST)a); or.hijos.add((AST)b); RESULT = or; :}
            | NOT expresion:b {: AST not = new AST("!"); not.hijos.add((AST)b); RESULT = not; :}

            | PARIZQ expresion:a PARDER {:RESULT= new AST("("+a+")");:} 
            | ENTERO:a {: RESULT= new AST(a); :}
            | DECIMAL:a {:RESULT= new AST(a);:}
            | ID:a {:RESULT= new AST(a);:}
            | STR:a {:RESULT=new AST(a);:}
            | CHAR:a {:RESULT=a;:}
            | BOOLEANO:a {:RESULT=a;:}
;

/*

| f:a {:RESULT=a;:}
f ::= ENTERO:a {:RESULT=a;:}
     |DECIMAL:a {:RESULT=a;:}
     
     |BOOLEANO:a {:RESULT=a;:}
;*/